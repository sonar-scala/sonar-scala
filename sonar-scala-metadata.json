{
  "repositories": {
    "sonar-scala-scalastyle": {
      "key": "sonar-scala-scalastyle",
      "name": "Scalastyle",
      "rules": [
        {
          "description": "*Check that there are no tabs in a file*\n\nSome say that tabs are evil.",
          "key": "org.scalastyle.file.FileTabChecker",
          "name": "Line contains Tab",
          "params": [
            {
              "default": "org.scalastyle.file.FileTabChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check the number of lines in a file*\n\nFiles which are too long can be hard to read and understand.",
          "key": "org.scalastyle.file.FileLengthChecker-template",
          "name": "File length",
          "params": [
            {
              "default": "1500",
              "description": "Maximum file length: Maximum number of lines in a file",
              "name": "maxFileLength",
              "typ": "Int"
            },
            {
              "default": "org.scalastyle.file.FileLengthChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Check the number of lines in a file*\n\nFiles which are too long can be hard to read and understand.",
          "key": "org.scalastyle.file.FileLengthChecker",
          "name": "File length",
          "params": [
            {
              "default": "1500",
              "description": "Maximum file length: Maximum number of lines in a file",
              "name": "maxFileLength",
              "typ": "Int"
            },
            {
              "default": "org.scalastyle.file.FileLengthChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check the first lines of each file matches the text*\n\nA lot of projects require a header with a copyright notice, or they require a license in each file. This does a simple text comparison between the header and the first lines of the file.\nYou can have multiple lines, but make sure you surround the text with a CDATA section. You can also specify a regular expression, as long as you set the regex parameter to true.",
          "key": "org.scalastyle.file.HeaderMatchesChecker-template",
          "name": "Match Header",
          "params": [
            {
              "default": "",
              "description": "Header: The lines to compare against",
              "name": "header",
              "typ": "String"
            },
            {
              "default": "false",
              "description": "Header Regex: Whether to treat the header string as a regular expression",
              "name": "regex",
              "typ": "Bool"
            },
            {
              "default": "org.scalastyle.file.HeaderMatchesChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Check that the plus sign is followed by a space*\n\nAn expression with spaces around + can be easier to read",
          "key": "org.scalastyle.scalariform.SpacesAfterPlusChecker",
          "name": "Space after plus",
          "params": [
            {
              "default": "org.scalastyle.scalariform.SpacesAfterPlusChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that there is no trailing whitespace at the end of lines*\n\nWhitespace at the end of a line can cause problems when diffing between files or between versions.",
          "key": "org.scalastyle.file.WhitespaceEndOfLineChecker-template",
          "name": "Whitespace at end of line",
          "params": [
            {
              "default": "false",
              "description": "Ignore lines with just whitespace: Skip a line if the entire contents are whitespace characters",
              "name": "ignoreWhitespaceLines",
              "typ": "Bool"
            },
            {
              "default": "org.scalastyle.file.WhitespaceEndOfLineChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Check that there is no trailing whitespace at the end of lines*\n\nWhitespace at the end of a line can cause problems when diffing between files or between versions.",
          "key": "org.scalastyle.file.WhitespaceEndOfLineChecker",
          "name": "Whitespace at end of line",
          "params": [
            {
              "default": "false",
              "description": "Ignore lines with just whitespace: Skip a line if the entire contents are whitespace characters",
              "name": "ignoreWhitespaceLines",
              "typ": "Bool"
            },
            {
              "default": "org.scalastyle.file.WhitespaceEndOfLineChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that the plus sign is preceded by a space*\n\nAn expression with spaces around + can be easier to read",
          "key": "org.scalastyle.scalariform.SpacesBeforePlusChecker",
          "name": "Space before plus",
          "params": [
            {
              "default": "org.scalastyle.scalariform.SpacesBeforePlusChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check the number of characters in a line*\n\nLines that are too long can be hard to read and horizontal scrolling is annoying.",
          "key": "org.scalastyle.file.FileLineLengthChecker-template",
          "name": "File line length",
          "params": [
            {
              "default": "160",
              "description": "Maximum line length: Maximum number of characters in a line",
              "name": "maxLineLength",
              "typ": "Int"
            },
            {
              "default": "4",
              "description": "Tab size: Number of characters that a tab represents",
              "name": "tabSize",
              "typ": "Int"
            },
            {
              "default": "false",
              "description": "Ignore import statements: Ignore import statements",
              "name": "ignoreImports",
              "typ": "Bool"
            },
            {
              "default": "org.scalastyle.file.FileLineLengthChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Check the number of characters in a line*\n\nLines that are too long can be hard to read and horizontal scrolling is annoying.",
          "key": "org.scalastyle.file.FileLineLengthChecker",
          "name": "File line length",
          "params": [
            {
              "default": "160",
              "description": "Maximum line length: Maximum number of characters in a line",
              "name": "maxLineLength",
              "typ": "Int"
            },
            {
              "default": "4",
              "description": "Tab size: Number of characters that a tab represents",
              "name": "tabSize",
              "typ": "Int"
            },
            {
              "default": "false",
              "description": "Ignore import statements: Ignore import statements",
              "name": "ignoreImports",
              "typ": "Bool"
            },
            {
              "default": "org.scalastyle.file.FileLineLengthChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that class names match a regular expression*\n\nThe Scala style guide recommends that class names conform to certain standards.",
          "key": "org.scalastyle.scalariform.ClassNamesChecker-template",
          "name": "Class name",
          "params": [
            {
              "default": "^[A-Z][A-Za-z]*$",
              "description": "Regular expression: The class names must match this regular expression",
              "name": "regex",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.ClassNamesChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Check that class names match a regular expression*\n\nThe Scala style guide recommends that class names conform to certain standards.",
          "key": "org.scalastyle.scalariform.ClassNamesChecker",
          "name": "Class name",
          "params": [
            {
              "default": "^[A-Z][A-Za-z]*$",
              "description": "Regular expression: The class names must match this regular expression",
              "name": "regex",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.ClassNamesChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that object names match a regular expression*\n\nThe Scala style guide recommends that object names conform to certain standards.",
          "key": "org.scalastyle.scalariform.ObjectNamesChecker-template",
          "name": "Object name",
          "params": [
            {
              "default": "^[A-Z][A-Za-z]*$",
              "description": "Regular expression: The object names must match this regular expression",
              "name": "regex",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.ObjectNamesChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Check that object names match a regular expression*\n\nThe Scala style guide recommends that object names conform to certain standards.",
          "key": "org.scalastyle.scalariform.ObjectNamesChecker",
          "name": "Object name",
          "params": [
            {
              "default": "^[A-Z][A-Za-z]*$",
              "description": "Regular expression: The object names must match this regular expression",
              "name": "regex",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.ObjectNamesChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that package names match a regular expression*\n\nThe Scala style guide recommends that package names conform to certain standards.",
          "key": "org.scalastyle.scalariform.PackageNamesChecker-template",
          "name": "Package name",
          "params": [
            {
              "default": "^[a-z][A-Za-z]*$",
              "description": "Regular expression: The package names must match this regular expression",
              "name": "regex",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.PackageNamesChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Check that package names match a regular expression*\n\nThe Scala style guide recommends that package names conform to certain standards.",
          "key": "org.scalastyle.scalariform.PackageNamesChecker",
          "name": "Package name",
          "params": [
            {
              "default": "^[a-z][A-Za-z]*$",
              "description": "Regular expression: The package names must match this regular expression",
              "name": "regex",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.PackageNamesChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that package object names match a regular expression*\n\nThe Scala style guide recommends that package object names conform to certain standards.",
          "key": "org.scalastyle.scalariform.PackageObjectNamesChecker-template",
          "name": "Package object name",
          "params": [
            {
              "default": "^[a-z][A-Za-z]*$",
              "description": "Regular expression: The package object names must match this regular expression",
              "name": "regex",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.PackageObjectNamesChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Check that package object names match a regular expression*\n\nThe Scala style guide recommends that package object names conform to certain standards.",
          "key": "org.scalastyle.scalariform.PackageObjectNamesChecker",
          "name": "Package object name",
          "params": [
            {
              "default": "^[a-z][A-Za-z]*$",
              "description": "Regular expression: The package object names must match this regular expression",
              "name": "regex",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.PackageObjectNamesChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that if a class implements either equals or hashCode, it should implement the other*\n\nDefining either equals or hashCode in a class without defining the is a known source of bugs. Usually, when you define one, you should also define the other.",
          "key": "org.scalastyle.scalariform.EqualsHashCodeChecker",
          "name": "Equals hashCode",
          "params": [
            {
              "default": "org.scalastyle.scalariform.EqualsHashCodeChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that a class does not import certain classes*\n\nUse of some classes can be discouraged for a project. For instance, use of sun._ is generally discouraged because\nthey are internal to the JDK and can be changed.",
          "key": "org.scalastyle.scalariform.IllegalImportsChecker-template",
          "name": "Illegal imports",
          "params": [
            {
              "default": "sun._,java.awt._",
              "description": "Illegal Imports: The comma separated list of illegal imports, wildcards allowed",
              "name": "illegalImports",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.IllegalImportsChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Check that a class does not import certain classes*\n\nUse of some classes can be discouraged for a project. For instance, use of sun._ is generally discouraged because\nthey are internal to the JDK and can be changed.",
          "key": "org.scalastyle.scalariform.IllegalImportsChecker",
          "name": "Illegal imports",
          "params": [
            {
              "default": "sun._,java.awt._",
              "description": "Illegal Imports: The comma separated list of illegal imports, wildcards allowed",
              "name": "illegalImports",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.IllegalImportsChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Maximum number of parameters for a method*\n\nA method which has more than a certain number of parameters can be hard to understand.",
          "key": "org.scalastyle.scalariform.ParameterNumberChecker-template",
          "name": "Maximum parameters",
          "params": [
            {
              "default": "8",
              "description": "Maximum Number: The maximum number of parameters",
              "name": "maxParameters",
              "typ": "Int"
            },
            {
              "default": "org.scalastyle.scalariform.ParameterNumberChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Maximum number of parameters for a method*\n\nA method which has more than a certain number of parameters can be hard to understand.",
          "key": "org.scalastyle.scalariform.ParameterNumberChecker",
          "name": "Maximum parameters",
          "params": [
            {
              "default": "8",
              "description": "Maximum Number: The maximum number of parameters",
              "name": "maxParameters",
              "typ": "Int"
            },
            {
              "default": "org.scalastyle.scalariform.ParameterNumberChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks for use of magic numbers*\n\nReplacing a magic number with a named constant can make code easier to read and understand, and can avoid some subtle bugs.\n\nA simple assignment to a val is not considered to be a magic number, for example:\n``\n    val foo = 4\n`` is not a magic number, but\n``\n    var foo = 4\n`` is considered to be a magic number.",
          "key": "org.scalastyle.scalariform.MagicNumberChecker-template",
          "name": "Magic Number",
          "params": [
            {
              "default": "-1,0,1,2",
              "description": "Ignore: The comma separated list of numbers to ignore when used as magic numbers",
              "name": "ignore",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.MagicNumberChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Checks for use of magic numbers*\n\nReplacing a magic number with a named constant can make code easier to read and understand, and can avoid some subtle bugs.\n\nA simple assignment to a val is not considered to be a magic number, for example:\n``\n    val foo = 4\n`` is not a magic number, but\n``\n    var foo = 4\n`` is considered to be a magic number.",
          "key": "org.scalastyle.scalariform.MagicNumberChecker",
          "name": "Magic Number",
          "params": [
            {
              "default": "-1,0,1,2",
              "description": "Ignore: The comma separated list of numbers to ignore when used as magic numbers",
              "name": "ignore",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.MagicNumberChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*No whitespace before left bracket ''[''*\n\nIf there is whitespace before a left bracket, this can be confusing to the reader",
          "key": "org.scalastyle.scalariform.NoWhitespaceBeforeLeftBracketChecker",
          "name": "No whitespace before left bracket ''[''",
          "params": [
            {
              "default": "org.scalastyle.scalariform.NoWhitespaceBeforeLeftBracketChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*No whitespace after left bracket ''[''*\n\nIf there is whitespace after a left bracket, this can be confusing to the reader",
          "key": "org.scalastyle.scalariform.NoWhitespaceAfterLeftBracketChecker",
          "name": "No whitespace after left bracket ''[''",
          "params": [
            {
              "default": "org.scalastyle.scalariform.NoWhitespaceAfterLeftBracketChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*No whitespace before right bracket '']''*\n\nIf there is whitespace before a right bracket, this can be confusing to the reader",
          "key": "org.scalastyle.scalariform.NoWhitespaceBeforeRightBracketChecker",
          "name": "No whitespace before right bracket '']''",
          "params": [
            {
              "default": "org.scalastyle.scalariform.NoWhitespaceBeforeRightBracketChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that return is not used*\n\nUse of return is not usually necessary in Scala. In fact, use of return can discourage a functional style of programming.",
          "key": "org.scalastyle.scalariform.ReturnChecker",
          "name": "Return",
          "params": [
            {
              "default": "org.scalastyle.scalariform.ReturnChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that null is not used*\n\nScala discourages use of nulls, preferring Option.",
          "key": "org.scalastyle.scalariform.NullChecker-template",
          "name": "Null",
          "params": [
            {
              "default": "true",
              "description": "Allow null checks: Allow occurrences in checks like 'x == null' or 'x != null'",
              "name": "allowNullChecks",
              "typ": "Bool"
            },
            {
              "default": "org.scalastyle.scalariform.NullChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Check that null is not used*\n\nScala discourages use of nulls, preferring Option.",
          "key": "org.scalastyle.scalariform.NullChecker",
          "name": "Null",
          "params": [
            {
              "default": "true",
              "description": "Allow null checks: Allow occurrences in checks like 'x == null' or 'x != null'",
              "name": "allowNullChecks",
              "typ": "Bool"
            },
            {
              "default": "org.scalastyle.scalariform.NullChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that classes and objects do not define the clone() method*\n\nThe clone method is difficult to get right. You can use the copy constructor of case classes rather than implementing clone.\nFor more information on clone(), see Effective Java by Joshua Bloch pages.",
          "key": "org.scalastyle.scalariform.NoCloneChecker",
          "name": "Clone method",
          "params": [
            {
              "default": "org.scalastyle.scalariform.NoCloneChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that classes and objects do not define the finalize() method*\n\nfinalize() is called when the object is garbage collected, and garbage collection is not guaranteed to happen.\nIt is therefore unwise to rely on code in finalize() method.",
          "key": "org.scalastyle.scalariform.NoFinalizeChecker",
          "name": "Finalize method",
          "params": [
            {
              "default": "org.scalastyle.scalariform.NoFinalizeChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that classes and objects do not define equals without overriding equals(java.lang.Object).*\n\nMistakenly defining a covariant equals() method without overriding method equals(java.lang.Object) can produce unexpected runtime behaviour.",
          "key": "org.scalastyle.scalariform.CovariantEqualsChecker",
          "name": "Covariant equals",
          "params": [
            {
              "default": "org.scalastyle.scalariform.CovariantEqualsChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that structural types are not used.*\n\nStructural types in Scala can use reflection - this can have unexpected performance consequences.\nWarning: This check can also wrongly pick up type lamdbas and other such constructs. This checker should be used with care. You always have the alternative of the scalac checking for structural types.",
          "key": "org.scalastyle.scalariform.StructuralTypeChecker",
          "name": "Structural type",
          "params": [
            {
              "default": "org.scalastyle.scalariform.StructuralTypeChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that a regular expression cannot be matched, if found reports this*\n\nSome checks can be carried out with a regular expression.",
          "key": "org.scalastyle.file.RegexChecker-template",
          "name": "Regular expression",
          "params": [
            {
              "default": "",
              "description": "Regular expression: Standard Scala regular expression syntax including multiline",
              "name": "regex",
              "typ": "String"
            },
            {
              "default": "false",
              "description": "Line: Boolean whether to process line by line",
              "name": "line",
              "typ": "Bool"
            },
            {
              "default": "org.scalastyle.file.RegexChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Checks that there are not too many types declared in a file*\n\nIf there are too many classes/objects defined in a single file, this can cause the code to be difficult to understand.",
          "key": "org.scalastyle.scalariform.NumberOfTypesChecker-template",
          "name": "Number of types",
          "params": [
            {
              "default": "20",
              "description": "Maximum Number: Maximum number of types to allow",
              "name": "maxTypes",
              "typ": "Int"
            },
            {
              "default": "org.scalastyle.scalariform.NumberOfTypesChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Checks that there are not too many types declared in a file*\n\nIf there are too many classes/objects defined in a single file, this can cause the code to be difficult to understand.",
          "key": "org.scalastyle.scalariform.NumberOfTypesChecker",
          "name": "Number of types",
          "params": [
            {
              "default": "20",
              "description": "Maximum Number: Maximum number of types to allow",
              "name": "maxTypes",
              "typ": "Int"
            },
            {
              "default": "org.scalastyle.scalariform.NumberOfTypesChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that the cyclomatic complexity of a method does exceed a value*\n\nIf the code is too complex, then this can make code hard to read.",
          "key": "org.scalastyle.scalariform.CyclomaticComplexityChecker-template",
          "name": "Cyclomatic complexity",
          "params": [
            {
              "default": "10",
              "description": "Maximum: Maximum cyclomatic complexity to allow for a method",
              "name": "maximum",
              "typ": "Int"
            },
            {
              "default": "true",
              "description": "Count Cases: If true, each case increases method complexity, else only match keyword is considered",
              "name": "countCases",
              "typ": "Bool"
            },
            {
              "default": "org.scalastyle.scalariform.CyclomaticComplexityChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Checks that the cyclomatic complexity of a method does exceed a value*\n\nIf the code is too complex, then this can make code hard to read.",
          "key": "org.scalastyle.scalariform.CyclomaticComplexityChecker",
          "name": "Cyclomatic complexity",
          "params": [
            {
              "default": "10",
              "description": "Maximum: Maximum cyclomatic complexity to allow for a method",
              "name": "maximum",
              "typ": "Int"
            },
            {
              "default": "true",
              "description": "Count Cases: If true, each case increases method complexity, else only match keyword is considered",
              "name": "countCases",
              "typ": "Bool"
            },
            {
              "default": "org.scalastyle.scalariform.CyclomaticComplexityChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that if a long literal is used, then an uppercase L is used*\n\nA lowercase L (l) can look similar to a number 1 with some fonts.",
          "key": "org.scalastyle.scalariform.UppercaseLChecker",
          "name": "Long literal uppercase L",
          "params": [
            {
              "default": "org.scalastyle.scalariform.UppercaseLChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Boolean expression can be simplified*\n\nA boolean expression which can be simplified can make code easier to read.",
          "key": "org.scalastyle.scalariform.SimplifyBooleanExpressionChecker",
          "name": "Simplify Boolean expression",
          "params": [
            {
              "default": "org.scalastyle.scalariform.SimplifyBooleanExpressionChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that if statements have braces*\n\nSome people find if clauses with braces easier to read.\n\nThe singleLineAllowed property allows if constructions of the type:\n``\n    if (bool_expression) expression1 else expression2\n`` The doubleLineAllowed property allows if constructions of the type:\n``\n    if (bool_expression) expression1\n    else expression2\n`` Note: If you intend to enable only if expressions in the format below, disable the IfBraceChecker altogether.\n``\n    if (bool_expression)\n      expression1\n    else\n      expression2\n``",
          "key": "org.scalastyle.scalariform.IfBraceChecker-template",
          "name": "If block braces",
          "params": [
            {
              "default": "true",
              "description": "Single Line Allowed: If without braces allowed if everything is on one line",
              "name": "singleLineAllowed",
              "typ": "Bool"
            },
            {
              "default": "false",
              "description": "Double Line Allowed: If without braces allowed if everything is on one line or two lines",
              "name": "doubleLineAllowed",
              "typ": "Bool"
            },
            {
              "default": "org.scalastyle.scalariform.IfBraceChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Checks that if statements have braces*\n\nSome people find if clauses with braces easier to read.\n\nThe singleLineAllowed property allows if constructions of the type:\n``\n    if (bool_expression) expression1 else expression2\n`` The doubleLineAllowed property allows if constructions of the type:\n``\n    if (bool_expression) expression1\n    else expression2\n`` Note: If you intend to enable only if expressions in the format below, disable the IfBraceChecker altogether.\n``\n    if (bool_expression)\n      expression1\n    else\n      expression2\n``",
          "key": "org.scalastyle.scalariform.IfBraceChecker",
          "name": "If block braces",
          "params": [
            {
              "default": "true",
              "description": "Single Line Allowed: If without braces allowed if everything is on one line",
              "name": "singleLineAllowed",
              "typ": "Bool"
            },
            {
              "default": "false",
              "description": "Double Line Allowed: If without braces allowed if everything is on one line or two lines",
              "name": "doubleLineAllowed",
              "typ": "Bool"
            },
            {
              "default": "org.scalastyle.scalariform.IfBraceChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that methods do not exceed a maximum length*\n\nLong methods can be hard to read and understand.",
          "key": "org.scalastyle.scalariform.MethodLengthChecker-template",
          "name": "Method length",
          "params": [
            {
              "default": "50",
              "description": "Maximum length: Maximum number of lines allowed for a method",
              "name": "maxLength",
              "typ": "Int"
            },
            {
              "default": "false",
              "description": "Ignore comments: If set to true, comment lines in method body won't be counted",
              "name": "ignoreComments",
              "typ": "Bool"
            },
            {
              "default": "false",
              "description": "Ignore empty lines: If set to true, empty lines in method body won't be counted",
              "name": "ignoreEmpty",
              "typ": "Bool"
            },
            {
              "default": "org.scalastyle.scalariform.MethodLengthChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Checks that methods do not exceed a maximum length*\n\nLong methods can be hard to read and understand.",
          "key": "org.scalastyle.scalariform.MethodLengthChecker",
          "name": "Method length",
          "params": [
            {
              "default": "50",
              "description": "Maximum length: Maximum number of lines allowed for a method",
              "name": "maxLength",
              "typ": "Int"
            },
            {
              "default": "false",
              "description": "Ignore comments: If set to true, comment lines in method body won't be counted",
              "name": "ignoreComments",
              "typ": "Bool"
            },
            {
              "default": "false",
              "description": "Ignore empty lines: If set to true, empty lines in method body won't be counted",
              "name": "ignoreEmpty",
              "typ": "Bool"
            },
            {
              "default": "org.scalastyle.scalariform.MethodLengthChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that method names match a regular expression*\n\nThe Scala style guide recommends that method names conform to certain standards. If the methods are overriding another method, and the overridden method\ncannot be changed, then use the ignoreOverride parameter.",
          "key": "org.scalastyle.scalariform.MethodNamesChecker-template",
          "name": "Method name",
          "params": [
            {
              "default": "^[a-z][A-Za-z0-9]*(_=)?$",
              "description": "Regular expression: The method names must match this regular expression",
              "name": "regex",
              "typ": "String"
            },
            {
              "default": "^$",
              "description": "Regular expression to ignore: Method names which match this regular expression will be ignored",
              "name": "ignoreRegex",
              "typ": "String"
            },
            {
              "default": "false",
              "description": "Ignore override: If set to true, methods which have the override modifier are ignored",
              "name": "ignoreOverride",
              "typ": "Bool"
            },
            {
              "default": "org.scalastyle.scalariform.MethodNamesChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Check that method names match a regular expression*\n\nThe Scala style guide recommends that method names conform to certain standards. If the methods are overriding another method, and the overridden method\ncannot be changed, then use the ignoreOverride parameter.",
          "key": "org.scalastyle.scalariform.MethodNamesChecker",
          "name": "Method name",
          "params": [
            {
              "default": "^[a-z][A-Za-z0-9]*(_=)?$",
              "description": "Regular expression: The method names must match this regular expression",
              "name": "regex",
              "typ": "String"
            },
            {
              "default": "^$",
              "description": "Regular expression to ignore: Method names which match this regular expression will be ignored",
              "name": "ignoreRegex",
              "typ": "String"
            },
            {
              "default": "false",
              "description": "Ignore override: If set to true, methods which have the override modifier are ignored",
              "name": "ignoreOverride",
              "typ": "Bool"
            },
            {
              "default": "org.scalastyle.scalariform.MethodNamesChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that method argument names match a regular expression*\n\nThe Scala style guide recommends that method argument names conform to certain standards.",
          "key": "org.scalastyle.scalariform.MethodArgumentNamesChecker-template",
          "name": "Method argument name",
          "params": [
            {
              "default": "^[a-z][A-Za-z0-9]*$",
              "description": "Regular expression: The method argument names must match this regular expression",
              "name": "regex",
              "typ": "String"
            },
            {
              "default": "^$",
              "description": "Regular expression to ignore: Method argument names which match this regular expression will be ignored",
              "name": "ignoreRegex",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.MethodArgumentNamesChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Check that method argument names match a regular expression*\n\nThe Scala style guide recommends that method argument names conform to certain standards.",
          "key": "org.scalastyle.scalariform.MethodArgumentNamesChecker",
          "name": "Method argument name",
          "params": [
            {
              "default": "^[a-z][A-Za-z0-9]*$",
              "description": "Regular expression: The method argument names must match this regular expression",
              "name": "regex",
              "typ": "String"
            },
            {
              "default": "^$",
              "description": "Regular expression to ignore: Method argument names which match this regular expression will be ignored",
              "name": "ignoreRegex",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.MethodArgumentNamesChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that a class / trait / object does not have too many methods*\n\nIf a type declares too many methods, this can be an indication of bad design.",
          "key": "org.scalastyle.scalariform.NumberOfMethodsInTypeChecker-template",
          "name": "Number of methods in type",
          "params": [
            {
              "default": "30",
              "description": "Maximum methods: The maximum number of methods allowed",
              "name": "maxMethods",
              "typ": "Int"
            },
            {
              "default": "org.scalastyle.scalariform.NumberOfMethodsInTypeChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Check that a class / trait / object does not have too many methods*\n\nIf a type declares too many methods, this can be an indication of bad design.",
          "key": "org.scalastyle.scalariform.NumberOfMethodsInTypeChecker",
          "name": "Number of methods in type",
          "params": [
            {
              "default": "30",
              "description": "Maximum methods: The maximum number of methods allowed",
              "name": "maxMethods",
              "typ": "Int"
            },
            {
              "default": "org.scalastyle.scalariform.NumberOfMethodsInTypeChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that a method has an explicit return type, it is not inferred*\n\nA public method declared on a type is effectively an API declaration. Explicitly declaring a return type means that other code which depends on that type won't break unexpectedly.",
          "key": "org.scalastyle.scalariform.PublicMethodsHaveTypeChecker-template",
          "name": "Public method must have type",
          "params": [
            {
              "default": "false",
              "description": "Ignore overridden methods: If true, public methods which override are ignored",
              "name": "ignoreOverride",
              "typ": "Bool"
            },
            {
              "default": "org.scalastyle.scalariform.PublicMethodsHaveTypeChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Check that a method has an explicit return type, it is not inferred*\n\nA public method declared on a type is effectively an API declaration. Explicitly declaring a return type means that other code which depends on that type won't break unexpectedly.",
          "key": "org.scalastyle.scalariform.PublicMethodsHaveTypeChecker",
          "name": "Public method must have type",
          "params": [
            {
              "default": "false",
              "description": "Ignore overridden methods: If true, public methods which override are ignored",
              "name": "ignoreOverride",
              "typ": "Bool"
            },
            {
              "default": "org.scalastyle.scalariform.PublicMethodsHaveTypeChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that a file ends with a newline character*\n\nSome version control systems don't cope well with files which don't end with a newline character.",
          "key": "org.scalastyle.file.NewLineAtEofChecker",
          "name": "Newline at EOF",
          "params": [
            {
              "default": "org.scalastyle.file.NewLineAtEofChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that a file does not end with a newline character*\n\nBecause Mirco Dotta wanted it.",
          "key": "org.scalastyle.file.NoNewLineAtEofChecker",
          "name": "No Newline at EOF",
          "params": [
            {
              "default": "org.scalastyle.file.NoNewLineAtEofChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that while is not used*\n\nwhile loops are deprecated if you're using a strict functional style",
          "key": "org.scalastyle.scalariform.WhileChecker",
          "name": "No while loops",
          "params": [
            {
              "default": "org.scalastyle.scalariform.WhileChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that classes and objects do not define mutable fields*\n\nvar (mutable fields) are deprecated if you're using a strict functional style",
          "key": "org.scalastyle.scalariform.VarFieldChecker",
          "name": "No mutable fields",
          "params": [
            {
              "default": "org.scalastyle.scalariform.VarFieldChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that functions do not define mutable variables*\n\nvars (mutable local variables) loops are deprecated if you're using a strict functional style",
          "key": "org.scalastyle.scalariform.VarLocalChecker",
          "name": "No mutable local variables",
          "params": [
            {
              "default": "org.scalastyle.scalariform.VarLocalChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that if expressions are not redundant, i.e. easily replaced by a variant of the condition*\n\nIf expressions with boolean constants in both branches can be eliminated without affecting readability. Prefer simply ``cond`` to ``if (cond) true else false`` and ``!cond`` to ``if (cond) false else true``.",
          "key": "org.scalastyle.scalariform.RedundantIfChecker",
          "name": "No redundant if expressions",
          "params": [
            {
              "default": "org.scalastyle.scalariform.RedundantIfChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that a regular expression cannot be matched in a token, if found reports this*\n\nSome checks can be carried by just the presence of a particular token.",
          "key": "org.scalastyle.scalariform.TokenChecker-template",
          "name": "Regular expression in a token",
          "params": [
            {
              "default": "^$",
              "description": "Regular expression: Standard Scala regular expression syntax",
              "name": "regex",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.TokenChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Checks that a regular expression cannot be matched in a token, if found reports this*\n\nSome checks can be carried by just the presence of a particular token.",
          "key": "org.scalastyle.scalariform.TokenChecker",
          "name": "Regular expression in a token",
          "params": [
            {
              "default": "^$",
              "description": "Regular expression: Standard Scala regular expression syntax",
              "name": "regex",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.TokenChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that Java @Deprecated is not used, Scala @deprecated should be used instead*\n\nYou should be using the Scala @deprecated instead.",
          "key": "org.scalastyle.scalariform.DeprecatedJavaChecker",
          "name": "No use of Java @Deprecated",
          "params": [
            {
              "default": "org.scalastyle.scalariform.DeprecatedJavaChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that Java @Override is not used*\n\nYou should be using the Scala override keyword instead.",
          "key": "org.scalastyle.scalariform.OverrideJavaChecker",
          "name": "No use of Java @Override",
          "params": [
            {
              "default": "org.scalastyle.scalariform.OverrideJavaChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*If a class/trait has no members, the braces are unnecessary*\n\nIf a class / trait has no members, then braces are unnecessary, and can be removed.",
          "key": "org.scalastyle.scalariform.EmptyClassChecker",
          "name": "Redundant braces in class definition",
          "params": [
            {
              "default": "org.scalastyle.scalariform.EmptyClassChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that type parameter to a class matches a regular expression*\n\nScala generic type names are generally single upper case letters. This check checks for classes and traits.\nNote that this check only checks the innermost type parameter, to allow for List[T].",
          "key": "org.scalastyle.scalariform.ClassTypeParameterChecker-template",
          "name": "Class type parameter name",
          "params": [
            {
              "default": "^[A-Z_]$",
              "description": "Regular expression: Standard Scala regular expression syntax",
              "name": "regex",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.ClassTypeParameterChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Checks that type parameter to a class matches a regular expression*\n\nScala generic type names are generally single upper case letters. This check checks for classes and traits.\nNote that this check only checks the innermost type parameter, to allow for List[T].",
          "key": "org.scalastyle.scalariform.ClassTypeParameterChecker",
          "name": "Class type parameter name",
          "params": [
            {
              "default": "^[A-Z_]$",
              "description": "Regular expression: Standard Scala regular expression syntax",
              "name": "regex",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.ClassTypeParameterChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Avoid wildcard imports*\n\nImporting all classes from a package or static members from a class leads to tight coupling between packages or classes and might lead to problems when a new version of a library introduces name clashes.",
          "key": "org.scalastyle.scalariform.UnderscoreImportChecker",
          "name": "Avoid wildcard imports",
          "params": [
            {
              "default": "org.scalastyle.scalariform.UnderscoreImportChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that a case statement pattern match is not lower case, as this can cause confusion*\n\nA lower case pattern match clause with no other tokens is the same as _; this is not true for patterns which start with an upper\ncase letter. This can cause confusion, and may not be what was intended:\n``\n    val foo = \"foo\"\n    val Bar = \"bar\"\n    \"bar\" match { case Bar => \"we got bar\" }   // result = \"we got bar\"\n    \"bar\" match { case foo => \"we got foo\" }   // result = \"we got foo\"\n    \"bar\" match { case `foo` => \"we got foo\" } // result = MatchError\n`` This checker raises a warning with the second match. To fix it, use an identifier which starts with an upper case letter (best), use case _ or,\nif you wish to refer to the value, add a type ``: Any``\n``\n    val lc = \"lc\"\n    \"something\" match { case lc: Any => \"lc\" } // result = \"lc\"\n    \"something\" match { case _ => \"lc\" } // result = \"lc\"\n``",
          "key": "org.scalastyle.scalariform.LowercasePatternMatchChecker",
          "name": "Lowercase pattern match",
          "params": [
            {
              "default": "org.scalastyle.scalariform.LowercasePatternMatchChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that a string literal does not appear multiple times*\n\nCode duplication makes maintenance more difficult, so it can be better to replace the multiple occurrences with a constant.",
          "key": "org.scalastyle.scalariform.MultipleStringLiteralsChecker-template",
          "name": "Multiple string literals",
          "params": [
            {
              "default": "1",
              "description": "Maximum occurences allowed: Maximum number of occurences allowed",
              "name": "allowed",
              "typ": "Int"
            },
            {
              "default": "^\"\"$",
              "description": "Ignore regular expression: Regular expression to ignore",
              "name": "ignoreRegex",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.MultipleStringLiteralsChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Checks that a string literal does not appear multiple times*\n\nCode duplication makes maintenance more difficult, so it can be better to replace the multiple occurrences with a constant.",
          "key": "org.scalastyle.scalariform.MultipleStringLiteralsChecker",
          "name": "Multiple string literals",
          "params": [
            {
              "default": "1",
              "description": "Maximum occurences allowed: Maximum number of occurences allowed",
              "name": "allowed",
              "typ": "Int"
            },
            {
              "default": "^\"\"$",
              "description": "Ignore regular expression: Regular expression to ignore",
              "name": "ignoreRegex",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.MultipleStringLiteralsChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that imports are grouped together, not throughout the file*\n\nIf imports are spread throughout the file, knowing what is in scope at any one place can be difficult to work out.",
          "key": "org.scalastyle.scalariform.ImportGroupingChecker",
          "name": "Group imports",
          "params": [
            {
              "default": "org.scalastyle.scalariform.ImportGroupingChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that the code does not have ??? operators.*\n\nThe ??? operator denotes that an implementation is missing. This rule helps to avoid potential runtime errors because of not implemented code.",
          "key": "org.scalastyle.scalariform.NotImplementedErrorUsage",
          "name": "Usage of ??? operator",
          "params": [
            {
              "default": "org.scalastyle.scalariform.NotImplementedErrorUsage",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that block imports are not used.*\n\nBlock imports (e.g. ``import a.{b, c}``) can lead to annoying merge errors in large code bases that are maintained by lot of developers. This rule allows to ensure that only single imports are used in order to minimize merge errors in import declarations.",
          "key": "org.scalastyle.scalariform.BlockImportChecker",
          "name": "Avoid block imports",
          "params": [
            {
              "default": "org.scalastyle.scalariform.BlockImportChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Use a : Unit = for procedure declarations*\n\nA procedure style declaration can cause confusion - the developer may have simply forgotten to add a '=', and now their method returns Unit rather than the inferred type:\n``\n    def foo() { println(\"hello\"); 5 }\n    def foo() = { println(\"hello\"); 5 }\n`` This checker raises a warning with the first line. To fix it, use an explicit return type, or add a '=' before the body.",
          "key": "org.scalastyle.scalariform.ProcedureDeclarationChecker",
          "name": "Use : Unit = for procedures",
          "params": [
            {
              "default": "org.scalastyle.scalariform.ProcedureDeclarationChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that braces are used in for comprehensions*\n\nUsage of braces (rather than parentheses) within a for comprehension mean that you don't have to specify a semi-colon at the end of every line:\n``\n    for {      // braces\n      t <- List(1,2,3)\n      if (i % 2 == 0)\n    } yield t\n`` is preferred to\n``\n    for (      // parentheses\n      t <- List(1,2,3);\n      if (i % 2 == 0)\n    ) yield t\n`` To fix it, replace the () with {}. And then remove the ; at the end of the lines.\n\nThe singleLineAllowed property allows for constructions of the type:\n``\n    for (i <- List(1,2,3)) yield i\n``",
          "key": "org.scalastyle.scalariform.ForBraceChecker-template",
          "name": "Use braces in for comprehensions",
          "params": [
            {
              "default": "false",
              "description": "Allow parentheses for single-line for: For with parentheses allowed if everything is on one line",
              "name": "singleLineAllowed",
              "typ": "Bool"
            },
            {
              "default": "org.scalastyle.scalariform.ForBraceChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Checks that braces are used in for comprehensions*\n\nUsage of braces (rather than parentheses) within a for comprehension mean that you don't have to specify a semi-colon at the end of every line:\n``\n    for {      // braces\n      t <- List(1,2,3)\n      if (i % 2 == 0)\n    } yield t\n`` is preferred to\n``\n    for (      // parentheses\n      t <- List(1,2,3);\n      if (i % 2 == 0)\n    ) yield t\n`` To fix it, replace the () with {}. And then remove the ; at the end of the lines.\n\nThe singleLineAllowed property allows for constructions of the type:\n``\n    for (i <- List(1,2,3)) yield i\n``",
          "key": "org.scalastyle.scalariform.ForBraceChecker",
          "name": "Use braces in for comprehensions",
          "params": [
            {
              "default": "false",
              "description": "Allow parentheses for single-line for: For with parentheses allowed if everything is on one line",
              "name": "singleLineAllowed",
              "typ": "Bool"
            },
            {
              "default": "org.scalastyle.scalariform.ForBraceChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that parentheses are used in for loops*\n\nFor-comprehensions which lack a yield clause is actually a loop rather than a functional comprehension and it is usually\n``\n   more readable to string the generators together between parentheses rather than using the syntactically-confusing } { construct:\n   for (x <- board.rows; y <- board.files) {\n     printf(\"(%d, %d)\", x, y)\n   }\n   is preferred to\n   for {\n     x <- board.rows\n     y <- board.files\n   } {\n     printf(\"(%d, %d)\", x, y)\n   }\n``",
          "key": "org.scalastyle.scalariform.ForLoopChecker",
          "name": "Use parentheses in for loops",
          "params": [
            {
              "default": "org.scalastyle.scalariform.ForLoopChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks a space after the start of the comment.*\n\nTo bring consistency with how comments should be formatted, leave a space right after the beginning of the comment.\n``\n    package foobar\n    object Foobar {\n    /**WRONG\n    *\n    */\n    /** Correct*/\n    val d = 2 /*Wrong*/ //Wrong\n    /**\n    *Correct\n    */\n    val e = 3/** Correct*/ // Correct\n    }\n``",
          "key": "org.scalastyle.scalariform.SpaceAfterCommentStartChecker",
          "name": "Space after the start of the comment",
          "params": [
            {
              "default": "org.scalastyle.scalariform.SpaceAfterCommentStartChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that the ScalaDoc on documentable members is well-formed*\n\nScaladoc is generally considered a good thing. Within reason.\n\nIgnore tokens is a comma separated string that may include the following : PatDefOrDcl (variables), TmplDef (classes, traits), TypeDefOrDcl (type definitions), FunDefOrDcl (functions)\nSupported indentation styles are \"scaladoc\" (for ScalaDoc-style comments, with two spaces before the asterisk), \"javadoc\" (for JavaDoc-style comments, with a single space before the asterisk) or \"anydoc\" to support any style (any number of spaces before the asterisk). For backwards compatibility, if left empty, \"anydoc\" will be assumed.",
          "key": "org.scalastyle.scalariform.ScalaDocChecker-template",
          "name": "Missing or badly formed ScalaDoc: {0}",
          "params": [
            {
              "default": "^$",
              "description": "Regular expression: Class names matching this regular expression will be ignored",
              "name": "ignoreRegex",
              "typ": "String"
            },
            {
              "default": "^$",
              "description": "Comma Separated String: Include the following to ignore : PatDefOrDcl (variables), TmplDef (classes, traits), TypeDefOrDcl (type definitions), FunDefOrDcl (functions)",
              "name": "ignoreTokenTypes",
              "typ": "String"
            },
            {
              "default": "false",
              "description": "Ignore override: If set to true, methods which have the override modifier are ignored",
              "name": "ignoreOverride",
              "typ": "Bool"
            },
            {
              "default": "anydoc",
              "description": "Force indent style: Possible values: scaladoc - 2 spaces before *, javadoc - 1 space before *",
              "name": "indentStyle",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.ScalaDocChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Disallow space after certain token(s)*\n\nCorrect formatting can help readability.",
          "key": "org.scalastyle.scalariform.DisallowSpaceAfterTokenChecker",
          "name": "Space after tokens",
          "params": [
            {
              "default": "org.scalastyle.scalariform.DisallowSpaceAfterTokenChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Disallow space before certain token(s)*\n\nCorrect formatting can help readability.",
          "key": "org.scalastyle.scalariform.DisallowSpaceBeforeTokenChecker",
          "name": "Space before tokens",
          "params": [
            {
              "default": "org.scalastyle.scalariform.DisallowSpaceBeforeTokenChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Ensure single space after certain token(s)*\n\nCorrect formatting can help readability.",
          "key": "org.scalastyle.scalariform.EnsureSingleSpaceAfterTokenChecker",
          "name": "No space after tokens",
          "params": [
            {
              "default": "org.scalastyle.scalariform.EnsureSingleSpaceAfterTokenChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Ensure single space before certain token(s)*\n\nCorrect formatting can help readability.",
          "key": "org.scalastyle.scalariform.EnsureSingleSpaceBeforeTokenChecker",
          "name": "No space before tokens",
          "params": [
            {
              "default": "org.scalastyle.scalariform.EnsureSingleSpaceBeforeTokenChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Some editors are unfriendly to non ASCII characters.*\n\nScala allows unicode characters as operators and some editors misbehave when they see non-ascii character.\n``\n    In a project collaborated by a community of developers. This check can be helpful in such situations.\n    \"value\".match {\n    case \"value\" => println(\"matched\")\n    ...\n    }\n    is preferred to\n    \"value\".match {\n    case \"value\"  println(\"matched\")\n    ...\n    }\n    To fix it, replace the (unicode operator) with =>.\n``",
          "key": "org.scalastyle.scalariform.NonASCIICharacterChecker-template",
          "name": "Non ASCII characters are not allowed",
          "params": [
            {
              "default": "false",
              "description": "Allow non-ASCII scripts in string literals.: White lists Unicode characters recognized by `\\p'{'Alnum'}'\\p'{'Punct'}'\\p'{'Sc'}'\\p'{'Space'}'` but not symbols like Emoji.",
              "name": "allowStringLiterals",
              "typ": "Bool"
            },
            {
              "default": "org.scalastyle.scalariform.NonASCIICharacterChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Some editors are unfriendly to non ASCII characters.*\n\nScala allows unicode characters as operators and some editors misbehave when they see non-ascii character.\n``\n    In a project collaborated by a community of developers. This check can be helpful in such situations.\n    \"value\".match {\n    case \"value\" => println(\"matched\")\n    ...\n    }\n    is preferred to\n    \"value\".match {\n    case \"value\"  println(\"matched\")\n    ...\n    }\n    To fix it, replace the (unicode operator) with =>.\n``",
          "key": "org.scalastyle.scalariform.NonASCIICharacterChecker",
          "name": "Non ASCII characters are not allowed",
          "params": [
            {
              "default": "false",
              "description": "Allow non-ASCII scripts in string literals.: White lists Unicode characters recognized by `\\p'{'Alnum'}'\\p'{'Punct'}'\\p'{'Sc'}'\\p'{'Space'}'` but not symbols like Emoji.",
              "name": "allowStringLiterals",
              "typ": "Bool"
            },
            {
              "default": "org.scalastyle.scalariform.NonASCIICharacterChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that lines are indented by a multiple of the tab size*\n\nCode that is not indented consistently can be hard to read.",
          "key": "org.scalastyle.file.IndentationChecker-template",
          "name": "Use correct indentation",
          "params": [
            {
              "default": "2",
              "description": "Tab size: Number of characters that a tab represents",
              "name": "tabSize",
              "typ": "Int"
            },
            {
              "default": "2",
              "description": "Multi-line method parameter spacing: Level of indentation of multi-line method parameters relative to the indentation of the first line of the method",
              "name": "methodParamIndentSize",
              "typ": "Int"
            },
            {
              "default": "4",
              "description": "Multi-line class parameter spacing: Level of indentation of multi-line primary constructor parameters of a class. Relative to the indentation of the first line of class declaration",
              "name": "classParamIndentSize",
              "typ": "Int"
            },
            {
              "default": "org.scalastyle.file.IndentationChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Checks that lines are indented by a multiple of the tab size*\n\nCode that is not indented consistently can be hard to read.",
          "key": "org.scalastyle.file.IndentationChecker",
          "name": "Use correct indentation",
          "params": [
            {
              "default": "2",
              "description": "Tab size: Number of characters that a tab represents",
              "name": "tabSize",
              "typ": "Int"
            },
            {
              "default": "2",
              "description": "Multi-line method parameter spacing: Level of indentation of multi-line method parameters relative to the indentation of the first line of the method",
              "name": "methodParamIndentSize",
              "typ": "Int"
            },
            {
              "default": "4",
              "description": "Multi-line class parameter spacing: Level of indentation of multi-line primary constructor parameters of a class. Relative to the indentation of the first line of class declaration",
              "name": "classParamIndentSize",
              "typ": "Int"
            },
            {
              "default": "org.scalastyle.file.IndentationChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that field names match a regular expression*\n\nA consistent naming convention for field names can make code easier to read and understand",
          "key": "org.scalastyle.scalariform.FieldNamesChecker-template",
          "name": "Field name",
          "params": [
            {
              "default": "^[a-z][A-Za-z0-9]*$",
              "description": "Regular expression: The field names must match this regular expression",
              "name": "regex",
              "typ": "String"
            },
            {
              "default": "^[A-Z][A-Za-z0-9]*$",
              "description": "Regular expression for constants: The object field (constant) names must match this regular expression",
              "name": "objectFieldRegex",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.FieldNamesChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Check that field names match a regular expression*\n\nA consistent naming convention for field names can make code easier to read and understand",
          "key": "org.scalastyle.scalariform.FieldNamesChecker",
          "name": "Field name",
          "params": [
            {
              "default": "^[a-z][A-Za-z0-9]*$",
              "description": "Regular expression: The field names must match this regular expression",
              "name": "regex",
              "typ": "String"
            },
            {
              "default": "^[A-Z][A-Za-z0-9]*$",
              "description": "Regular expression for constants: The object field (constant) names must match this regular expression",
              "name": "objectFieldRegex",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.FieldNamesChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that XML literals are not used*\n\nSome projects prefer not to have XML literals. They could use a templating engine instead.",
          "key": "org.scalastyle.scalariform.XmlLiteralChecker",
          "name": "XML literals",
          "params": [
            {
              "default": "org.scalastyle.scalariform.XmlLiteralChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that imports are grouped and ordered according to the style configuration.*\n\nConsistent import ordering improves code readability and reduces unrelated changes in patches.",
          "key": "org.scalastyle.scalariform.ImportOrderChecker",
          "name": "Import Order",
          "params": [
            {
              "default": "org.scalastyle.scalariform.ImportOrderChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that pattern match arrows align*\n\nCorrect formatting can help readability.",
          "key": "org.scalastyle.scalariform.PatternMatchAlignChecker",
          "name": "Pattern match align",
          "params": [
            {
              "default": "org.scalastyle.scalariform.PatternMatchAlignChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check for use of TODO/FIXME single line comments*\n\nSome projects may consider TODO or FIXME comments in a code bad style. They would rather you fix the problem.",
          "key": "org.scalastyle.scalariform.TodoCommentChecker-template",
          "name": "TODO/FIXME comment",
          "params": [
            {
              "default": "TODO|FIXME",
              "description": "Word list: Alternative list of words to look for, separated by |",
              "name": "words",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.TodoCommentChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Check for use of TODO/FIXME single line comments*\n\nSome projects may consider TODO or FIXME comments in a code bad style. They would rather you fix the problem.",
          "key": "org.scalastyle.scalariform.TodoCommentChecker",
          "name": "TODO/FIXME comment",
          "params": [
            {
              "default": "TODO|FIXME",
              "description": "Word list: Alternative list of words to look for, separated by |",
              "name": "words",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.TodoCommentChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*The interpolation for this string literal is not necessary*\n\nEmpty interpolated strings are harder to read and not necessary.",
          "key": "org.scalastyle.scalariform.EmptyInterpolatedStringChecker",
          "name": "Empty interpolated string",
          "params": [
            {
              "default": "org.scalastyle.scalariform.EmptyInterpolatedStringChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that argument literals are named*\n\nNameless literals make code harder to understand (consider ``updateEntity(1, true)`` and ``updateEntity(id = 1, enabled = true)``).",
          "key": "org.scalastyle.scalariform.NamedArgumentChecker-template",
          "name": "Literal passed as argument without name",
          "params": [
            {
              "default": "false",
              "description": "Check string literals: If true, also checks that string literal arguments are named",
              "name": "checkString",
              "typ": "Bool"
            },
            {
              "default": "^set.+$",
              "description": "Ignore methods by pattern: Pattern to ignore method calls by name",
              "name": "ignoreMethod",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.NamedArgumentChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Checks that argument literals are named*\n\nNameless literals make code harder to understand (consider ``updateEntity(1, true)`` and ``updateEntity(id = 1, enabled = true)``).",
          "key": "org.scalastyle.scalariform.NamedArgumentChecker",
          "name": "Literal passed as argument without name",
          "params": [
            {
              "default": "false",
              "description": "Check string literals: If true, also checks that string literal arguments are named",
              "name": "checkString",
              "typ": "Bool"
            },
            {
              "default": "^set.+$",
              "description": "Ignore methods by pattern: Pattern to ignore method calls by name",
              "name": "ignoreMethod",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.NamedArgumentChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that while body have braces*\n\nWhile cannot be used in a pure-functional manner, that's why it's recommended to never omit braces according to Scala Style Guide.",
          "key": "org.scalastyle.scalariform.WhileBraceChecker",
          "name": "While body should have braces",
          "params": [
            {
              "default": "org.scalastyle.scalariform.WhileBraceChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that braces aren't used in case clauses*\n\nBraces aren't required in case clauses. They should be omitted according to Scala Style Guide.",
          "key": "org.scalastyle.scalariform.CaseBraceChecker",
          "name": "Omit braces in case clauses",
          "params": [
            {
              "default": "org.scalastyle.scalariform.CaseBraceChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        }
      ]
    }
  },
  "rules": {
    "scalastyle": [
      {
        "description": "*Check that there are no tabs in a file*\n\nSome say that tabs are evil.",
        "key": "org.scalastyle.file.FileTabChecker",
        "name": "Line contains Tab",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Check the number of lines in a file*\n\nFiles which are too long can be hard to read and understand.",
        "key": "org.scalastyle.file.FileLengthChecker",
        "name": "File length",
        "params": [
          {
            "default": "1500",
            "description": "Maximum file length: Maximum number of lines in a file",
            "name": "maxFileLength",
            "typ": "Int"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Check the first lines of each file matches the text*\n\nA lot of projects require a header with a copyright notice, or they require a license in each file. This does a simple text comparison between the header and the first lines of the file.\nYou can have multiple lines, but make sure you surround the text with a CDATA section. You can also specify a regular expression, as long as you set the regex parameter to true.",
        "key": "org.scalastyle.file.HeaderMatchesChecker",
        "name": "Match Header",
        "params": [
          {
            "default": "",
            "description": "Header: The lines to compare against",
            "name": "header",
            "typ": "String"
          },
          {
            "default": "false",
            "description": "Header Regex: Whether to treat the header string as a regular expression",
            "name": "regex",
            "typ": "Bool"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Check that the plus sign is followed by a space*\n\nAn expression with spaces around + can be easier to read",
        "key": "org.scalastyle.scalariform.SpacesAfterPlusChecker",
        "name": "Space after plus",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Check that there is no trailing whitespace at the end of lines*\n\nWhitespace at the end of a line can cause problems when diffing between files or between versions.",
        "key": "org.scalastyle.file.WhitespaceEndOfLineChecker",
        "name": "Whitespace at end of line",
        "params": [
          {
            "default": "false",
            "description": "Ignore lines with just whitespace: Skip a line if the entire contents are whitespace characters",
            "name": "ignoreWhitespaceLines",
            "typ": "Bool"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Check that the plus sign is preceded by a space*\n\nAn expression with spaces around + can be easier to read",
        "key": "org.scalastyle.scalariform.SpacesBeforePlusChecker",
        "name": "Space before plus",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Check the number of characters in a line*\n\nLines that are too long can be hard to read and horizontal scrolling is annoying.",
        "key": "org.scalastyle.file.FileLineLengthChecker",
        "name": "File line length",
        "params": [
          {
            "default": "160",
            "description": "Maximum line length: Maximum number of characters in a line",
            "name": "maxLineLength",
            "typ": "Int"
          },
          {
            "default": "4",
            "description": "Tab size: Number of characters that a tab represents",
            "name": "tabSize",
            "typ": "Int"
          },
          {
            "default": "false",
            "description": "Ignore import statements: Ignore import statements",
            "name": "ignoreImports",
            "typ": "Bool"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Check that class names match a regular expression*\n\nThe Scala style guide recommends that class names conform to certain standards.",
        "key": "org.scalastyle.scalariform.ClassNamesChecker",
        "name": "Class name",
        "params": [
          {
            "default": "^[A-Z][A-Za-z]*$",
            "description": "Regular expression: The class names must match this regular expression",
            "name": "regex",
            "typ": "String"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Check that object names match a regular expression*\n\nThe Scala style guide recommends that object names conform to certain standards.",
        "key": "org.scalastyle.scalariform.ObjectNamesChecker",
        "name": "Object name",
        "params": [
          {
            "default": "^[A-Z][A-Za-z]*$",
            "description": "Regular expression: The object names must match this regular expression",
            "name": "regex",
            "typ": "String"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Check that package names match a regular expression*\n\nThe Scala style guide recommends that package names conform to certain standards.",
        "key": "org.scalastyle.scalariform.PackageNamesChecker",
        "name": "Package name",
        "params": [
          {
            "default": "^[a-z][A-Za-z]*$",
            "description": "Regular expression: The package names must match this regular expression",
            "name": "regex",
            "typ": "String"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Check that package object names match a regular expression*\n\nThe Scala style guide recommends that package object names conform to certain standards.",
        "key": "org.scalastyle.scalariform.PackageObjectNamesChecker",
        "name": "Package object name",
        "params": [
          {
            "default": "^[a-z][A-Za-z]*$",
            "description": "Regular expression: The package object names must match this regular expression",
            "name": "regex",
            "typ": "String"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Check that if a class implements either equals or hashCode, it should implement the other*\n\nDefining either equals or hashCode in a class without defining the is a known source of bugs. Usually, when you define one, you should also define the other.",
        "key": "org.scalastyle.scalariform.EqualsHashCodeChecker",
        "name": "Equals hashCode",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Check that a class does not import certain classes*\n\nUse of some classes can be discouraged for a project. For instance, use of sun._ is generally discouraged because\nthey are internal to the JDK and can be changed.",
        "key": "org.scalastyle.scalariform.IllegalImportsChecker",
        "name": "Illegal imports",
        "params": [
          {
            "default": "sun._,java.awt._",
            "description": "Illegal Imports: The comma separated list of illegal imports, wildcards allowed",
            "name": "illegalImports",
            "typ": "String"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Maximum number of parameters for a method*\n\nA method which has more than a certain number of parameters can be hard to understand.",
        "key": "org.scalastyle.scalariform.ParameterNumberChecker",
        "name": "Maximum parameters",
        "params": [
          {
            "default": "8",
            "description": "Maximum Number: The maximum number of parameters",
            "name": "maxParameters",
            "typ": "Int"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Checks for use of magic numbers*\n\nReplacing a magic number with a named constant can make code easier to read and understand, and can avoid some subtle bugs.\n\nA simple assignment to a val is not considered to be a magic number, for example:\n``\n    val foo = 4\n`` is not a magic number, but\n``\n    var foo = 4\n`` is considered to be a magic number.",
        "key": "org.scalastyle.scalariform.MagicNumberChecker",
        "name": "Magic Number",
        "params": [
          {
            "default": "-1,0,1,2",
            "description": "Ignore: The comma separated list of numbers to ignore when used as magic numbers",
            "name": "ignore",
            "typ": "String"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*No whitespace before left bracket ''[''*\n\nIf there is whitespace before a left bracket, this can be confusing to the reader",
        "key": "org.scalastyle.scalariform.NoWhitespaceBeforeLeftBracketChecker",
        "name": "No whitespace before left bracket ''[''",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*No whitespace after left bracket ''[''*\n\nIf there is whitespace after a left bracket, this can be confusing to the reader",
        "key": "org.scalastyle.scalariform.NoWhitespaceAfterLeftBracketChecker",
        "name": "No whitespace after left bracket ''[''",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*No whitespace before right bracket '']''*\n\nIf there is whitespace before a right bracket, this can be confusing to the reader",
        "key": "org.scalastyle.scalariform.NoWhitespaceBeforeRightBracketChecker",
        "name": "No whitespace before right bracket '']''",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Check that return is not used*\n\nUse of return is not usually necessary in Scala. In fact, use of return can discourage a functional style of programming.",
        "key": "org.scalastyle.scalariform.ReturnChecker",
        "name": "Return",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Check that null is not used*\n\nScala discourages use of nulls, preferring Option.",
        "key": "org.scalastyle.scalariform.NullChecker",
        "name": "Null",
        "params": [
          {
            "default": "true",
            "description": "Allow null checks: Allow occurrences in checks like 'x == null' or 'x != null'",
            "name": "allowNullChecks",
            "typ": "Bool"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Check that classes and objects do not define the clone() method*\n\nThe clone method is difficult to get right. You can use the copy constructor of case classes rather than implementing clone.\nFor more information on clone(), see Effective Java by Joshua Bloch pages.",
        "key": "org.scalastyle.scalariform.NoCloneChecker",
        "name": "Clone method",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Check that classes and objects do not define the finalize() method*\n\nfinalize() is called when the object is garbage collected, and garbage collection is not guaranteed to happen.\nIt is therefore unwise to rely on code in finalize() method.",
        "key": "org.scalastyle.scalariform.NoFinalizeChecker",
        "name": "Finalize method",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Check that classes and objects do not define equals without overriding equals(java.lang.Object).*\n\nMistakenly defining a covariant equals() method without overriding method equals(java.lang.Object) can produce unexpected runtime behaviour.",
        "key": "org.scalastyle.scalariform.CovariantEqualsChecker",
        "name": "Covariant equals",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Check that structural types are not used.*\n\nStructural types in Scala can use reflection - this can have unexpected performance consequences.\nWarning: This check can also wrongly pick up type lamdbas and other such constructs. This checker should be used with care. You always have the alternative of the scalac checking for structural types.",
        "key": "org.scalastyle.scalariform.StructuralTypeChecker",
        "name": "Structural type",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks that a regular expression cannot be matched, if found reports this*\n\nSome checks can be carried out with a regular expression.",
        "key": "org.scalastyle.file.RegexChecker",
        "name": "Regular expression",
        "params": [
          {
            "default": "",
            "description": "Regular expression: Standard Scala regular expression syntax including multiline",
            "name": "regex",
            "typ": "String"
          },
          {
            "default": "false",
            "description": "Line: Boolean whether to process line by line",
            "name": "line",
            "typ": "Bool"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Checks that there are not too many types declared in a file*\n\nIf there are too many classes/objects defined in a single file, this can cause the code to be difficult to understand.",
        "key": "org.scalastyle.scalariform.NumberOfTypesChecker",
        "name": "Number of types",
        "params": [
          {
            "default": "20",
            "description": "Maximum Number: Maximum number of types to allow",
            "name": "maxTypes",
            "typ": "Int"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Checks that the cyclomatic complexity of a method does exceed a value*\n\nIf the code is too complex, then this can make code hard to read.",
        "key": "org.scalastyle.scalariform.CyclomaticComplexityChecker",
        "name": "Cyclomatic complexity",
        "params": [
          {
            "default": "10",
            "description": "Maximum: Maximum cyclomatic complexity to allow for a method",
            "name": "maximum",
            "typ": "Int"
          },
          {
            "default": "true",
            "description": "Count Cases: If true, each case increases method complexity, else only match keyword is considered",
            "name": "countCases",
            "typ": "Bool"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Checks that if a long literal is used, then an uppercase L is used*\n\nA lowercase L (l) can look similar to a number 1 with some fonts.",
        "key": "org.scalastyle.scalariform.UppercaseLChecker",
        "name": "Long literal uppercase L",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Boolean expression can be simplified*\n\nA boolean expression which can be simplified can make code easier to read.",
        "key": "org.scalastyle.scalariform.SimplifyBooleanExpressionChecker",
        "name": "Simplify Boolean expression",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks that if statements have braces*\n\nSome people find if clauses with braces easier to read.\n\nThe singleLineAllowed property allows if constructions of the type:\n``\n    if (bool_expression) expression1 else expression2\n`` The doubleLineAllowed property allows if constructions of the type:\n``\n    if (bool_expression) expression1\n    else expression2\n`` Note: If you intend to enable only if expressions in the format below, disable the IfBraceChecker altogether.\n``\n    if (bool_expression)\n      expression1\n    else\n      expression2\n``",
        "key": "org.scalastyle.scalariform.IfBraceChecker",
        "name": "If block braces",
        "params": [
          {
            "default": "true",
            "description": "Single Line Allowed: If without braces allowed if everything is on one line",
            "name": "singleLineAllowed",
            "typ": "Bool"
          },
          {
            "default": "false",
            "description": "Double Line Allowed: If without braces allowed if everything is on one line or two lines",
            "name": "doubleLineAllowed",
            "typ": "Bool"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Checks that methods do not exceed a maximum length*\n\nLong methods can be hard to read and understand.",
        "key": "org.scalastyle.scalariform.MethodLengthChecker",
        "name": "Method length",
        "params": [
          {
            "default": "50",
            "description": "Maximum length: Maximum number of lines allowed for a method",
            "name": "maxLength",
            "typ": "Int"
          },
          {
            "default": "false",
            "description": "Ignore comments: If set to true, comment lines in method body won't be counted",
            "name": "ignoreComments",
            "typ": "Bool"
          },
          {
            "default": "false",
            "description": "Ignore empty lines: If set to true, empty lines in method body won't be counted",
            "name": "ignoreEmpty",
            "typ": "Bool"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Check that method names match a regular expression*\n\nThe Scala style guide recommends that method names conform to certain standards. If the methods are overriding another method, and the overridden method\ncannot be changed, then use the ignoreOverride parameter.",
        "key": "org.scalastyle.scalariform.MethodNamesChecker",
        "name": "Method name",
        "params": [
          {
            "default": "^[a-z][A-Za-z0-9]*(_=)?$",
            "description": "Regular expression: The method names must match this regular expression",
            "name": "regex",
            "typ": "String"
          },
          {
            "default": "^$",
            "description": "Regular expression to ignore: Method names which match this regular expression will be ignored",
            "name": "ignoreRegex",
            "typ": "String"
          },
          {
            "default": "false",
            "description": "Ignore override: If set to true, methods which have the override modifier are ignored",
            "name": "ignoreOverride",
            "typ": "Bool"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Check that method argument names match a regular expression*\n\nThe Scala style guide recommends that method argument names conform to certain standards.",
        "key": "org.scalastyle.scalariform.MethodArgumentNamesChecker",
        "name": "Method argument name",
        "params": [
          {
            "default": "^[a-z][A-Za-z0-9]*$",
            "description": "Regular expression: The method argument names must match this regular expression",
            "name": "regex",
            "typ": "String"
          },
          {
            "default": "^$",
            "description": "Regular expression to ignore: Method argument names which match this regular expression will be ignored",
            "name": "ignoreRegex",
            "typ": "String"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Check that a class / trait / object does not have too many methods*\n\nIf a type declares too many methods, this can be an indication of bad design.",
        "key": "org.scalastyle.scalariform.NumberOfMethodsInTypeChecker",
        "name": "Number of methods in type",
        "params": [
          {
            "default": "30",
            "description": "Maximum methods: The maximum number of methods allowed",
            "name": "maxMethods",
            "typ": "Int"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Check that a method has an explicit return type, it is not inferred*\n\nA public method declared on a type is effectively an API declaration. Explicitly declaring a return type means that other code which depends on that type won't break unexpectedly.",
        "key": "org.scalastyle.scalariform.PublicMethodsHaveTypeChecker",
        "name": "Public method must have type",
        "params": [
          {
            "default": "false",
            "description": "Ignore overridden methods: If true, public methods which override are ignored",
            "name": "ignoreOverride",
            "typ": "Bool"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Checks that a file ends with a newline character*\n\nSome version control systems don't cope well with files which don't end with a newline character.",
        "key": "org.scalastyle.file.NewLineAtEofChecker",
        "name": "Newline at EOF",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks that a file does not end with a newline character*\n\nBecause Mirco Dotta wanted it.",
        "key": "org.scalastyle.file.NoNewLineAtEofChecker",
        "name": "No Newline at EOF",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks that while is not used*\n\nwhile loops are deprecated if you're using a strict functional style",
        "key": "org.scalastyle.scalariform.WhileChecker",
        "name": "No while loops",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks that classes and objects do not define mutable fields*\n\nvar (mutable fields) are deprecated if you're using a strict functional style",
        "key": "org.scalastyle.scalariform.VarFieldChecker",
        "name": "No mutable fields",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks that functions do not define mutable variables*\n\nvars (mutable local variables) loops are deprecated if you're using a strict functional style",
        "key": "org.scalastyle.scalariform.VarLocalChecker",
        "name": "No mutable local variables",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks that if expressions are not redundant, i.e. easily replaced by a variant of the condition*\n\nIf expressions with boolean constants in both branches can be eliminated without affecting readability. Prefer simply ``cond`` to ``if (cond) true else false`` and ``!cond`` to ``if (cond) false else true``.",
        "key": "org.scalastyle.scalariform.RedundantIfChecker",
        "name": "No redundant if expressions",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks that a regular expression cannot be matched in a token, if found reports this*\n\nSome checks can be carried by just the presence of a particular token.",
        "key": "org.scalastyle.scalariform.TokenChecker",
        "name": "Regular expression in a token",
        "params": [
          {
            "default": "^$",
            "description": "Regular expression: Standard Scala regular expression syntax",
            "name": "regex",
            "typ": "String"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Checks that Java @Deprecated is not used, Scala @deprecated should be used instead*\n\nYou should be using the Scala @deprecated instead.",
        "key": "org.scalastyle.scalariform.DeprecatedJavaChecker",
        "name": "No use of Java @Deprecated",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks that Java @Override is not used*\n\nYou should be using the Scala override keyword instead.",
        "key": "org.scalastyle.scalariform.OverrideJavaChecker",
        "name": "No use of Java @Override",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*If a class/trait has no members, the braces are unnecessary*\n\nIf a class / trait has no members, then braces are unnecessary, and can be removed.",
        "key": "org.scalastyle.scalariform.EmptyClassChecker",
        "name": "Redundant braces in class definition",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks that type parameter to a class matches a regular expression*\n\nScala generic type names are generally single upper case letters. This check checks for classes and traits.\nNote that this check only checks the innermost type parameter, to allow for List[T].",
        "key": "org.scalastyle.scalariform.ClassTypeParameterChecker",
        "name": "Class type parameter name",
        "params": [
          {
            "default": "^[A-Z_]$",
            "description": "Regular expression: Standard Scala regular expression syntax",
            "name": "regex",
            "typ": "String"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Avoid wildcard imports*\n\nImporting all classes from a package or static members from a class leads to tight coupling between packages or classes and might lead to problems when a new version of a library introduces name clashes.",
        "key": "org.scalastyle.scalariform.UnderscoreImportChecker",
        "name": "Avoid wildcard imports",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks that a case statement pattern match is not lower case, as this can cause confusion*\n\nA lower case pattern match clause with no other tokens is the same as _; this is not true for patterns which start with an upper\ncase letter. This can cause confusion, and may not be what was intended:\n``\n    val foo = \"foo\"\n    val Bar = \"bar\"\n    \"bar\" match { case Bar => \"we got bar\" }   // result = \"we got bar\"\n    \"bar\" match { case foo => \"we got foo\" }   // result = \"we got foo\"\n    \"bar\" match { case `foo` => \"we got foo\" } // result = MatchError\n`` This checker raises a warning with the second match. To fix it, use an identifier which starts with an upper case letter (best), use case _ or,\nif you wish to refer to the value, add a type ``: Any``\n``\n    val lc = \"lc\"\n    \"something\" match { case lc: Any => \"lc\" } // result = \"lc\"\n    \"something\" match { case _ => \"lc\" } // result = \"lc\"\n``",
        "key": "org.scalastyle.scalariform.LowercasePatternMatchChecker",
        "name": "Lowercase pattern match",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks that a string literal does not appear multiple times*\n\nCode duplication makes maintenance more difficult, so it can be better to replace the multiple occurrences with a constant.",
        "key": "org.scalastyle.scalariform.MultipleStringLiteralsChecker",
        "name": "Multiple string literals",
        "params": [
          {
            "default": "1",
            "description": "Maximum occurences allowed: Maximum number of occurences allowed",
            "name": "allowed",
            "typ": "Int"
          },
          {
            "default": "^\"\"$",
            "description": "Ignore regular expression: Regular expression to ignore",
            "name": "ignoreRegex",
            "typ": "String"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Checks that imports are grouped together, not throughout the file*\n\nIf imports are spread throughout the file, knowing what is in scope at any one place can be difficult to work out.",
        "key": "org.scalastyle.scalariform.ImportGroupingChecker",
        "name": "Group imports",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks that the code does not have ??? operators.*\n\nThe ??? operator denotes that an implementation is missing. This rule helps to avoid potential runtime errors because of not implemented code.",
        "key": "org.scalastyle.scalariform.NotImplementedErrorUsage",
        "name": "Usage of ??? operator",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks that block imports are not used.*\n\nBlock imports (e.g. ``import a.{b, c}``) can lead to annoying merge errors in large code bases that are maintained by lot of developers. This rule allows to ensure that only single imports are used in order to minimize merge errors in import declarations.",
        "key": "org.scalastyle.scalariform.BlockImportChecker",
        "name": "Avoid block imports",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Use a : Unit = for procedure declarations*\n\nA procedure style declaration can cause confusion - the developer may have simply forgotten to add a '=', and now their method returns Unit rather than the inferred type:\n``\n    def foo() { println(\"hello\"); 5 }\n    def foo() = { println(\"hello\"); 5 }\n`` This checker raises a warning with the first line. To fix it, use an explicit return type, or add a '=' before the body.",
        "key": "org.scalastyle.scalariform.ProcedureDeclarationChecker",
        "name": "Use : Unit = for procedures",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks that braces are used in for comprehensions*\n\nUsage of braces (rather than parentheses) within a for comprehension mean that you don't have to specify a semi-colon at the end of every line:\n``\n    for {      // braces\n      t <- List(1,2,3)\n      if (i % 2 == 0)\n    } yield t\n`` is preferred to\n``\n    for (      // parentheses\n      t <- List(1,2,3);\n      if (i % 2 == 0)\n    ) yield t\n`` To fix it, replace the () with {}. And then remove the ; at the end of the lines.\n\nThe singleLineAllowed property allows for constructions of the type:\n``\n    for (i <- List(1,2,3)) yield i\n``",
        "key": "org.scalastyle.scalariform.ForBraceChecker",
        "name": "Use braces in for comprehensions",
        "params": [
          {
            "default": "false",
            "description": "Allow parentheses for single-line for: For with parentheses allowed if everything is on one line",
            "name": "singleLineAllowed",
            "typ": "Bool"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Checks that parentheses are used in for loops*\n\nFor-comprehensions which lack a yield clause is actually a loop rather than a functional comprehension and it is usually\n``\n   more readable to string the generators together between parentheses rather than using the syntactically-confusing } { construct:\n   for (x <- board.rows; y <- board.files) {\n     printf(\"(%d, %d)\", x, y)\n   }\n   is preferred to\n   for {\n     x <- board.rows\n     y <- board.files\n   } {\n     printf(\"(%d, %d)\", x, y)\n   }\n``",
        "key": "org.scalastyle.scalariform.ForLoopChecker",
        "name": "Use parentheses in for loops",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks a space after the start of the comment.*\n\nTo bring consistency with how comments should be formatted, leave a space right after the beginning of the comment.\n``\n    package foobar\n    object Foobar {\n    /**WRONG\n    *\n    */\n    /** Correct*/\n    val d = 2 /*Wrong*/ //Wrong\n    /**\n    *Correct\n    */\n    val e = 3/** Correct*/ // Correct\n    }\n``",
        "key": "org.scalastyle.scalariform.SpaceAfterCommentStartChecker",
        "name": "Space after the start of the comment",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks that the ScalaDoc on documentable members is well-formed*\n\nScaladoc is generally considered a good thing. Within reason.\n\nIgnore tokens is a comma separated string that may include the following : PatDefOrDcl (variables), TmplDef (classes, traits), TypeDefOrDcl (type definitions), FunDefOrDcl (functions)\nSupported indentation styles are \"scaladoc\" (for ScalaDoc-style comments, with two spaces before the asterisk), \"javadoc\" (for JavaDoc-style comments, with a single space before the asterisk) or \"anydoc\" to support any style (any number of spaces before the asterisk). For backwards compatibility, if left empty, \"anydoc\" will be assumed.",
        "key": "org.scalastyle.scalariform.ScalaDocChecker",
        "name": "Missing or badly formed ScalaDoc: {0}",
        "params": [
          {
            "default": "^$",
            "description": "Regular expression: Class names matching this regular expression will be ignored",
            "name": "ignoreRegex",
            "typ": "String"
          },
          {
            "default": "^$",
            "description": "Comma Separated String: Include the following to ignore : PatDefOrDcl (variables), TmplDef (classes, traits), TypeDefOrDcl (type definitions), FunDefOrDcl (functions)",
            "name": "ignoreTokenTypes",
            "typ": "String"
          },
          {
            "default": "false",
            "description": "Ignore override: If set to true, methods which have the override modifier are ignored",
            "name": "ignoreOverride",
            "typ": "Bool"
          },
          {
            "default": "anydoc",
            "description": "Force indent style: Possible values: scaladoc - 2 spaces before *, javadoc - 1 space before *",
            "name": "indentStyle",
            "typ": "String"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Disallow space after certain token(s)*\n\nCorrect formatting can help readability.",
        "key": "org.scalastyle.scalariform.DisallowSpaceAfterTokenChecker",
        "name": "Space after tokens",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Disallow space before certain token(s)*\n\nCorrect formatting can help readability.",
        "key": "org.scalastyle.scalariform.DisallowSpaceBeforeTokenChecker",
        "name": "Space before tokens",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Ensure single space after certain token(s)*\n\nCorrect formatting can help readability.",
        "key": "org.scalastyle.scalariform.EnsureSingleSpaceAfterTokenChecker",
        "name": "No space after tokens",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Ensure single space before certain token(s)*\n\nCorrect formatting can help readability.",
        "key": "org.scalastyle.scalariform.EnsureSingleSpaceBeforeTokenChecker",
        "name": "No space before tokens",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Some editors are unfriendly to non ASCII characters.*\n\nScala allows unicode characters as operators and some editors misbehave when they see non-ascii character.\n``\n    In a project collaborated by a community of developers. This check can be helpful in such situations.\n    \"value\".match {\n    case \"value\" => println(\"matched\")\n    ...\n    }\n    is preferred to\n    \"value\".match {\n    case \"value\"  println(\"matched\")\n    ...\n    }\n    To fix it, replace the (unicode operator) with =>.\n``",
        "key": "org.scalastyle.scalariform.NonASCIICharacterChecker",
        "name": "Non ASCII characters are not allowed",
        "params": [
          {
            "default": "false",
            "description": "Allow non-ASCII scripts in string literals.: White lists Unicode characters recognized by `\\p'{'Alnum'}'\\p'{'Punct'}'\\p'{'Sc'}'\\p'{'Space'}'` but not symbols like Emoji.",
            "name": "allowStringLiterals",
            "typ": "Bool"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Checks that lines are indented by a multiple of the tab size*\n\nCode that is not indented consistently can be hard to read.",
        "key": "org.scalastyle.file.IndentationChecker",
        "name": "Use correct indentation",
        "params": [
          {
            "default": "2",
            "description": "Tab size: Number of characters that a tab represents",
            "name": "tabSize",
            "typ": "Int"
          },
          {
            "default": "2",
            "description": "Multi-line method parameter spacing: Level of indentation of multi-line method parameters relative to the indentation of the first line of the method",
            "name": "methodParamIndentSize",
            "typ": "Int"
          },
          {
            "default": "4",
            "description": "Multi-line class parameter spacing: Level of indentation of multi-line primary constructor parameters of a class. Relative to the indentation of the first line of class declaration",
            "name": "classParamIndentSize",
            "typ": "Int"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Check that field names match a regular expression*\n\nA consistent naming convention for field names can make code easier to read and understand",
        "key": "org.scalastyle.scalariform.FieldNamesChecker",
        "name": "Field name",
        "params": [
          {
            "default": "^[a-z][A-Za-z0-9]*$",
            "description": "Regular expression: The field names must match this regular expression",
            "name": "regex",
            "typ": "String"
          },
          {
            "default": "^[A-Z][A-Za-z0-9]*$",
            "description": "Regular expression for constants: The object field (constant) names must match this regular expression",
            "name": "objectFieldRegex",
            "typ": "String"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Check that XML literals are not used*\n\nSome projects prefer not to have XML literals. They could use a templating engine instead.",
        "key": "org.scalastyle.scalariform.XmlLiteralChecker",
        "name": "XML literals",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks that imports are grouped and ordered according to the style configuration.*\n\nConsistent import ordering improves code readability and reduces unrelated changes in patches.",
        "key": "org.scalastyle.scalariform.ImportOrderChecker",
        "name": "Import Order",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Check that pattern match arrows align*\n\nCorrect formatting can help readability.",
        "key": "org.scalastyle.scalariform.PatternMatchAlignChecker",
        "name": "Pattern match align",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Check for use of TODO/FIXME single line comments*\n\nSome projects may consider TODO or FIXME comments in a code bad style. They would rather you fix the problem.",
        "key": "org.scalastyle.scalariform.TodoCommentChecker",
        "name": "TODO/FIXME comment",
        "params": [
          {
            "default": "TODO|FIXME",
            "description": "Word list: Alternative list of words to look for, separated by |",
            "name": "words",
            "typ": "String"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*The interpolation for this string literal is not necessary*\n\nEmpty interpolated strings are harder to read and not necessary.",
        "key": "org.scalastyle.scalariform.EmptyInterpolatedStringChecker",
        "name": "Empty interpolated string",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks that argument literals are named*\n\nNameless literals make code harder to understand (consider ``updateEntity(1, true)`` and ``updateEntity(id = 1, enabled = true)``).",
        "key": "org.scalastyle.scalariform.NamedArgumentChecker",
        "name": "Literal passed as argument without name",
        "params": [
          {
            "default": "false",
            "description": "Check string literals: If true, also checks that string literal arguments are named",
            "name": "checkString",
            "typ": "Bool"
          },
          {
            "default": "^set.+$",
            "description": "Ignore methods by pattern: Pattern to ignore method calls by name",
            "name": "ignoreMethod",
            "typ": "String"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Checks that while body have braces*\n\nWhile cannot be used in a pure-functional manner, that's why it's recommended to never omit braces according to Scala Style Guide.",
        "key": "org.scalastyle.scalariform.WhileBraceChecker",
        "name": "While body should have braces",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks that braces aren't used in case clauses*\n\nBraces aren't required in case clauses. They should be omitted according to Scala Style Guide.",
        "key": "org.scalastyle.scalariform.CaseBraceChecker",
        "name": "Omit braces in case clauses",
        "params": [],
        "severity": "Minor",
        "template": false
      }
    ]
  }
}
